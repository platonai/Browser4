package ai.platon.pulsar.common.concurrent

import org.junit.jupiter.api.Test
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.Timeout
import java.time.Duration
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import kotlin.test.*

/**
 * AI-generated comprehensive unit tests for ConcurrentPassiveExpiringSet
 * Generated by AutoCoder with target coverage: 80%+
 * Fixed compilation errors - using consistent types
 */
class ConcurrentPassiveExpiringSetAITest {

    private lateinit var expiringSet: ConcurrentPassiveExpiringSet<String>
    private lateinit var neverExpireSet: ConcurrentPassiveExpiringSet<String>

    @BeforeEach
    fun setUp() {
        expiringSet = ConcurrentPassiveExpiringSet(Duration.ofSeconds(1))
        neverExpireSet = ConcurrentPassiveExpiringSet(Duration.ofSeconds(-1))
    }

    @AfterEach
    fun tearDown() {
        // Clean up resources if needed
    }

    // ===== Basic Operations Tests =====

    @Test
    fun testAddAndContains() {
        // Arrange
        val element = "test-element"

        // Act
        val added = expiringSet.add(element)
        val contains = expiringSet.contains(element)

        // Assert
        assertTrue(added, "Element should be added successfully")
        assertTrue(contains, "Set should contain the added element")
        assertEquals(1, expiringSet.size, "Set size should be 1")
    }

    @Test
    fun testAddDuplicateElement() {
        // Arrange
        val element = "duplicate-element"
        expiringSet.add(element)

        // Act
        val secondAdd = expiringSet.add(element)

        // Assert
        assertFalse(secondAdd, "Adding duplicate should return false")
        assertEquals(1, expiringSet.size, "Size should remain 1")
    }

    @Test
    fun testRemoveElement() {
        // Arrange
        val element = "to-remove"
        expiringSet.add(element)
        assertTrue(expiringSet.contains(element))

        // Act
        val removed = expiringSet.remove(element)

        // Assert
        assertTrue(removed, "Element should be removed successfully")
        assertFalse(expiringSet.contains(element), "Set should not contain removed element")
        assertEquals(0, expiringSet.size, "Set should be empty")
    }

    @Test
    fun testRemoveNonExistentElement() {
        // Arrange
        val element = "non-existent"

        // Act
        val removed = expiringSet.remove(element)

        // Assert
        assertFalse(removed, "Removing non-existent element should return false")
        assertEquals(0, expiringSet.size, "Size should remain 0")
    }

    // ===== Expiration Tests =====

    @Test
    @Timeout(value = 5, unit = TimeUnit.SECONDS)
    fun testElementExpiration() {
        // Arrange
        val element = "expiring-element"
        expiringSet.add(element)

        // Act & Assert
        assertTrue(expiringSet.contains(element), "Element should exist immediately after adding")

        // Wait for expiration
        Thread.sleep(1100) // Wait 1.1 seconds (100ms buffer)

        // Assert
        assertFalse(expiringSet.contains(element), "Element should be expired after TTL")
        assertTrue(expiringSet.isEmpty(), "Set should be empty after expiration")
    }

    @Test
    fun testNeverExpireSet() {
        // Arrange
        val element = "never-expire"
        neverExpireSet.add(element)

        // Act
        val containsBefore = neverExpireSet.contains(element)
        Thread.sleep(100) // Short wait
        val containsAfter = neverExpireSet.contains(element)

        // Assert
        assertTrue(containsBefore, "Element should exist immediately")
        assertTrue(containsAfter, "Element should still exist after short wait")
        assertEquals(1, neverExpireSet.size, "Size should remain 1")
    }

    // ===== Bulk Operations Tests =====

    @Test
    fun testAddAll() {
        // Arrange
        val elements = listOf("a", "b", "c", "d")

        // Act
        val changed = expiringSet.addAll(elements)

        // Assert
        assertTrue(changed, "Set should be modified by addAll")
        assertEquals(4, expiringSet.size, "All elements should be added")
        assertTrue(expiringSet.containsAll(elements), "Set should contain all added elements")
    }

    @Test
    fun testAddAllWithDuplicates() {
        // Arrange
        expiringSet.add("existing")
        val elements = listOf("existing", "new1", "new2")

        // Act
        val changed = expiringSet.addAll(elements)

        // Assert
        assertTrue(changed, "Set should be modified")
        assertEquals(3, expiringSet.size, "Only new elements should be added")
        assertTrue(expiringSet.contains("existing"), "Original element should still exist")
        assertTrue(expiringSet.contains("new1"), "New elements should be added")
    }

    @Test
    fun testRemoveAll() {
        // Arrange
        val elements = listOf("a", "b", "c")
        expiringSet.addAll(elements)

        // Act
        val changed = expiringSet.removeAll(elements)

        // Assert
        assertTrue(changed, "Set should be modified by removeAll")
        assertEquals(0, expiringSet.size, "All elements should be removed")
        assertFalse(expiringSet.contains("a"), "No elements should remain")
    }

    @Test
    fun testRetainAll() {
        // Arrange
        expiringSet.addAll(listOf("a", "b", "c", "d"))
        val retainElements = listOf("b", "d", "e") // e doesn't exist

        // Act
        val changed = expiringSet.retainAll(retainElements)

        // Assert
        assertTrue(changed, "Set should be modified")
        assertEquals(2, expiringSet.size, "Only retained elements should remain")
        assertTrue(expiringSet.containsAll(listOf("b", "d")))
        assertFalse(expiringSet.contains("a"))
        assertFalse(expiringSet.contains("c"))
    }

    // ===== Iterator Tests =====

    @Test
    fun testIterator() {
        // Arrange
        val elements = setOf("a", "b", "c")
        expiringSet.addAll(elements)

        // Act
        val iteratedElements = expiringSet.toSet()

        // Assert
        assertEquals(elements, iteratedElements, "Iterator should return all elements")
    }

    @Test
    fun testIteratorWithExpiredElements() {
        // Arrange
        expiringSet.add("expire-soon")
        Thread.sleep(1100) // Wait for expiration
        expiringSet.add("still-valid")

        // Act
        val iteratedElements = expiringSet.toSet()

        // Assert
        assertEquals(setOf("still-valid"), iteratedElements, "Iterator should only return non-expired elements")
    }

    // ===== Concurrent Access Tests =====

    @Test
    fun testConcurrentAdditions() {
        // Arrange
        val threadCount = 10
        val elementsPerThread = 100
        val executor = Executors.newFixedThreadPool(threadCount)
        val latch = CountDownLatch(threadCount)

        // Act
        for (i in 0 until threadCount) {
            executor.submit {
                try {
                    for (j in 0 until elementsPerThread) {
                        neverExpireSet.add("thread-$i-element-$j")
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        latch.await()
        executor.shutdown()

        // Assert
        assertEquals(threadCount * elementsPerThread, neverExpireSet.size,
            "All concurrent additions should succeed")
    }

    @Test
    fun testConcurrentReadWrite() {
        // Arrange
        val writeExecutor = Executors.newSingleThreadExecutor()
        val readExecutor = Executors.newSingleThreadExecutor()
        val writeLatch = CountDownLatch(1)
        val readLatch = CountDownLatch(1)

        var readSuccessCount = 0

        // Act - Writer thread
        writeExecutor.submit {
            for (i in 0 until 100) {
                neverExpireSet.add("concurrent-$i")
                Thread.sleep(10) // Small delay between writes
            }
            writeLatch.countDown()
        }

        // Act - Reader thread
        readExecutor.submit {
            for (i in 0 until 100) {
                if (neverExpireSet.contains("concurrent-$i")) {
                    readSuccessCount++
                }
                Thread.sleep(10) // Small delay between reads
            }
            readLatch.countDown()
        }

        writeLatch.await()
        readLatch.await()
        writeExecutor.shutdown()
        readExecutor.shutdown()

        // Assert
        assertTrue(readSuccessCount > 0, "Should have successfully read some elements")
        assertEquals(100, neverExpireSet.size, "All elements should be added")
    }

    // ===== Edge Cases Tests =====

    @Test
    fun testEmptySet() {
        // Arrange (already empty)

        // Act & Assert
        assertTrue(expiringSet.isEmpty(), "New set should be empty")
        assertEquals(0, expiringSet.size, "Size should be 0")
        assertFalse(expiringSet.iterator().hasNext(), "Iterator should be empty")
        assertFalse(expiringSet.contains("anything"), "Should not contain any element")
    }

    @Test
    fun testClear() {
        // Arrange
        expiringSet.addAll(listOf("a", "b", "c"))
        assertEquals(3, expiringSet.size)

        // Act
        expiringSet.clear()

        // Assert
        assertTrue(expiringSet.isEmpty(), "Set should be empty after clear")
        assertEquals(0, expiringSet.size, "Size should be 0 after clear")
    }

    @Test
    fun testEqualsContract() {
        // Arrange
        val set1 = ConcurrentPassiveExpiringSet<String>()
        val set2 = ConcurrentPassiveExpiringSet<String>()
        val set3 = ConcurrentPassiveExpiringSet<String>()

        // Act
        set1.add("a")
        set2.add("a")
        set3.add("b")

        // Assert - Reflexive
        assertEquals(set1, set1, "Set should equal itself")

        // Assert - Symmetric
        assertEquals(set1, set2, "Sets with same elements should be equal")
        assertEquals(set2, set1, "Equality should be symmetric")

        // Assert - Different elements
        assertNotEquals(set1, set3, "Sets with different elements should not be equal")
    }

    @Test
    fun testHashCodeContract() {
        // Arrange
        val set1 = ConcurrentPassiveExpiringSet<String>()
        val set2 = ConcurrentPassiveExpiringSet<String>()

        // Act
        set1.addAll(listOf("a", "b"))
        set2.addAll(listOf("b", "a")) // Same elements, different order

        // Assert
        assertEquals(set1.hashCode(), set2.hashCode(),
            "Sets with same elements should have same hash code")
        assertEquals(set1, set2, "Sets should be equal")
    }

    // ===== Performance Tests =====

    @Test
    fun testLargeDatasetPerformance() {
        // Arrange
        val largeDataset = (1..1000).map { "element-$it" }
        val startTime = System.currentTimeMillis()

        // Act
        neverExpireSet.addAll(largeDataset)
        val containsResult = neverExpireSet.contains("element-500")
        val endTime = System.currentTimeMillis()

        // Assert
        assertTrue(containsResult, "Should find middle element")
        assertEquals(1000, neverExpireSet.size, "All elements should be added")
        assertTrue((endTime - startTime) < 1000, "Operations should complete within reasonable time")
    }
}